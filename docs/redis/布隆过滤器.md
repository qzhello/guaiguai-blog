---
title: 布隆过滤器
# 禁用目录
toc: true
comments: true
weight: 1
---
# 布隆过滤器

## 布隆过滤器和Set
```shell
布隆过滤器（Bloom Filter）和 Set 在判断 ID 唯一性时各有优势，选择布隆过滤器的主要原因是：
内存效率
布隆过滤器使用位数组存储数据，每个元素只占用几个比特
Set 需要存储完整的 ID，如果是 UUID 这样的长字符串，会占用更多内存
例如：存储 1 百万个 UUID，Set 可能需要 100MB+ 内存，而布隆过滤器可能只需要 1-2MB
可接受的误判
布隆过滤器有一定的误判率（False Positive），但没有漏判（False Negative）
在很多场景下，这个误判是可以接受的，比如：
缓存防击穿：即使误判了几次，最多就是多查了几次数据库
ID 去重：偶尔的误判导致重复请求被拦截，不会影响系统正确性
分布式友好
布隆过滤器容易合并，多个布隆过滤器可以通过按位 OR 操作合并
在分布式系统中，可以在不同节点维护本地布隆过滤器，然后定期合并
空间固定
布隆过滤器的空间是预先分配的，不会随着数据增加而增长
Set 会随着元素增加而扩容，可能导致内存使用不可预测
不过，布隆过滤器也有其局限性：
不能删除元素
标准布隆过滤器不支持删除操作（虽然有变体如 Counting Bloom Filter 支持）
Set 可以自由地添加和删除元素
有误判可能
如果业务要求 100% 准确，不能容忍误判，就应该使用 Set
比如支付系统的订单 ID 去重，就不适合用布隆过滤器
所以选择布隆过滤器还是 Set，主要取决于：
内存资源是否紧张
是否能容忍误判
是否需要删除元素
分布式需求
准确性要求
在大多数高并发系统中，布隆过滤器是一个很好的选择，因为它能在可接受的误判率下，极大地节省内存资源。但如果你的系统对准确性要求极高，或者数据量较小，使用 Set 可能是更好的选择。
```

# 如何削峰




